{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AsyncFIX - AsyncIO FIX Protocol Python Framework AsyncIO FIX protocol library for Python Highlights Pythonic way of dealing with FIX messages Schema validation Tools for unit testing client apps NewOrderSingle container / state management support Session management included (FIX journaling, session restoring, heartbeats, resets) FIX Tester - tool for FIX unit testing (schema validation, order management, protocol message exchange) FIX 4.4 protocol implemented 100% unit test code coverage Installation pip install asyncfix Getting started Simple snippets Client example Full Documentation Credits This project initially intended to be a fork of AIOPyFIX , but things went too deep and too far. Hopefully, this project could help. Please, star this repo if you are going to use this project. License MIT 2023 Aleksandr Vedeneev","title":"Home"},{"location":"#asyncfix-asyncio-fix-protocol-python-framework","text":"AsyncIO FIX protocol library for Python","title":"AsyncFIX - AsyncIO FIX Protocol Python Framework"},{"location":"#highlights","text":"Pythonic way of dealing with FIX messages Schema validation Tools for unit testing client apps NewOrderSingle container / state management support Session management included (FIX journaling, session restoring, heartbeats, resets) FIX Tester - tool for FIX unit testing (schema validation, order management, protocol message exchange) FIX 4.4 protocol implemented 100% unit test code coverage","title":"Highlights"},{"location":"#installation","text":"pip install asyncfix","title":"Installation"},{"location":"#getting-started","text":"Simple snippets Client example Full Documentation","title":"Getting started"},{"location":"#credits","text":"This project initially intended to be a fork of AIOPyFIX , but things went too deep and too far. Hopefully, this project could help. Please, star this repo if you are going to use this project.","title":"Credits"},{"location":"#license","text":"MIT 2023 Aleksandr Vedeneev","title":"License"},{"location":"examples/","text":"AsyncFIX Framework Examples Fix message management from asyncfix import FIXMessage, FTag, FMsg from asyncfix.protocol import FOrdType msg = FIXMessage( FMsg.NEWORDERSINGLE, {11: \"clordis\", \"1\": \"account\", FTag.Price: 21.21, FTag.OrderQty: 2}, ) # duplicate tag setting not allowed, needs replace msg.set(FTag.Price, 22.22, replace=True) # Can set by item msg[FTag.Symbol] = 'TEST.SYM' # Or integer tag msg[40] = FOrdType.LIMIT msg.set_group( FTag.NoAllocs, [{FTag.AllocID: 1, FTag.AllocAvgPx: 1}, {FTag.AllocID: 2, FTag.AllocAvgPx: 2}], ) print(msg) # > 11=clordis|1=account|44=22.22|38=2|55=TEST.SYM|40=2|78=2=>[70=1|153=1, 70=2|153=2] print(repr(msg[40])) # > '2' print(msg.get_group_list(FTag.NoAllocs)) # > [70=1|153=1, 70=2|153=2] print(msg.query(11, FTag.Price, \"40\")) # > {<FTag.ClOrdID: '11'>: 'clordis', <FTag.Price: '44'>: '22.22', <FTag.OrdType: '40'>: '2'} # noqa FIX Validation by schema from asyncfix.protocol import FIXSchema from asyncfix import FIXMessage, FMsg, FTag from asyncfix.errors import FIXMessageError import os schema_file = os.path.abspath( os.path.join(os.path.dirname(__file__), \"..\", \"tests\", \"FIX44.xml\") ) schema = FIXSchema(schema_file) m = FIXMessage(FMsg.LOGON, {FTag.EncryptMethod: \"0\", FTag.HeartBtInt: 20}) # Passes! assert schema.validate(m) # Bad message m = FIXMessage(FMsg.LOGON, {FTag.EncryptMethod: \"0\"}) try: schema.validate(m) assert False except FIXMessageError as exc: print(f\"Message validation failed: `{repr(m)}`: {repr(exc)}\") Order Management and testing from asyncfix.protocol import ( FIXNewOrderSingle, FOrdSide, FOrdStatus, FExecType, ) from asyncfix import FIXTester order = FIXNewOrderSingle( \"clordTest\", \"US.F.TICKER\", side=FOrdSide.BUY, price=200.0, qty=10 ) print(\"Send new\") print(order.new_req()) # > 11=clordTest--1|55=US.F.TICKER|1=000000|40=2|54=1|60=20231014-14:22:44.278|44=200.0|38=10 o = FIXNewOrderSingle( \"clordTest\", \"US.F.TICKER\", side=FOrdSide.BUY, price=200.0, qty=10 ) ft = FIXTester(schema=None) # Optionally allows schema for validation assert ft.order_register_single(o) == 1 assert o.status == FOrdStatus.CREATED, f\"o.status={chr(o.status)}\" exep_rep_msg = ft.fix_exec_report_msg( o, o.clord_id, FExecType.PENDING_NEW, FOrdStatus.PENDING_NEW ) print('FIXTester exec report') print(exep_rep_msg) # > 11=clordTest|37=1|17=10001|150=A|39=A|54=1|14=0.0|151=0.0|55=US.F.TICKER|44=200.0|38=10|6=0.0|1=000000 # Order processes exec report internally and maintains itself assert o.process_execution_report(exep_rep_msg) == 1","title":"Examples"},{"location":"examples/#asyncfix-framework-examples","text":"","title":"AsyncFIX Framework Examples"},{"location":"examples/#fix-message-management","text":"from asyncfix import FIXMessage, FTag, FMsg from asyncfix.protocol import FOrdType msg = FIXMessage( FMsg.NEWORDERSINGLE, {11: \"clordis\", \"1\": \"account\", FTag.Price: 21.21, FTag.OrderQty: 2}, ) # duplicate tag setting not allowed, needs replace msg.set(FTag.Price, 22.22, replace=True) # Can set by item msg[FTag.Symbol] = 'TEST.SYM' # Or integer tag msg[40] = FOrdType.LIMIT msg.set_group( FTag.NoAllocs, [{FTag.AllocID: 1, FTag.AllocAvgPx: 1}, {FTag.AllocID: 2, FTag.AllocAvgPx: 2}], ) print(msg) # > 11=clordis|1=account|44=22.22|38=2|55=TEST.SYM|40=2|78=2=>[70=1|153=1, 70=2|153=2] print(repr(msg[40])) # > '2' print(msg.get_group_list(FTag.NoAllocs)) # > [70=1|153=1, 70=2|153=2] print(msg.query(11, FTag.Price, \"40\")) # > {<FTag.ClOrdID: '11'>: 'clordis', <FTag.Price: '44'>: '22.22', <FTag.OrdType: '40'>: '2'} # noqa","title":"Fix message management"},{"location":"examples/#fix-validation-by-schema","text":"from asyncfix.protocol import FIXSchema from asyncfix import FIXMessage, FMsg, FTag from asyncfix.errors import FIXMessageError import os schema_file = os.path.abspath( os.path.join(os.path.dirname(__file__), \"..\", \"tests\", \"FIX44.xml\") ) schema = FIXSchema(schema_file) m = FIXMessage(FMsg.LOGON, {FTag.EncryptMethod: \"0\", FTag.HeartBtInt: 20}) # Passes! assert schema.validate(m) # Bad message m = FIXMessage(FMsg.LOGON, {FTag.EncryptMethod: \"0\"}) try: schema.validate(m) assert False except FIXMessageError as exc: print(f\"Message validation failed: `{repr(m)}`: {repr(exc)}\")","title":"FIX Validation by schema"},{"location":"examples/#order-management-and-testing","text":"from asyncfix.protocol import ( FIXNewOrderSingle, FOrdSide, FOrdStatus, FExecType, ) from asyncfix import FIXTester order = FIXNewOrderSingle( \"clordTest\", \"US.F.TICKER\", side=FOrdSide.BUY, price=200.0, qty=10 ) print(\"Send new\") print(order.new_req()) # > 11=clordTest--1|55=US.F.TICKER|1=000000|40=2|54=1|60=20231014-14:22:44.278|44=200.0|38=10 o = FIXNewOrderSingle( \"clordTest\", \"US.F.TICKER\", side=FOrdSide.BUY, price=200.0, qty=10 ) ft = FIXTester(schema=None) # Optionally allows schema for validation assert ft.order_register_single(o) == 1 assert o.status == FOrdStatus.CREATED, f\"o.status={chr(o.status)}\" exep_rep_msg = ft.fix_exec_report_msg( o, o.clord_id, FExecType.PENDING_NEW, FOrdStatus.PENDING_NEW ) print('FIXTester exec report') print(exep_rep_msg) # > 11=clordTest|37=1|17=10001|150=A|39=A|54=1|14=0.0|151=0.0|55=US.F.TICKER|44=200.0|38=10|6=0.0|1=000000 # Order processes exec report internally and maintains itself assert o.process_execution_report(exep_rep_msg) == 1","title":"Order Management and testing"},{"location":"reference/","text":"API Overview Modules codec : FIX Message encoding / decoding module. connection : Abstract connection module. connection_client : FIX Initiator (client) connection. connection_server : Dummy FIX server module. errors : AsyncFIX errors module. fix_tester : FIX Protocol Unit Tester. fixtags : FIX Tags collection module. journaler : Generic SQLite Journaler. message : FIX message and containers module. msgtype : Message type module. protocol : AsyncFIX protocol package. protocol.common : Common FIX protocol enums. protocol.order_single : Generic FIX Order single module. protocol.protocol_base : Base FIX protocol. protocol.protocol_fix44 : FIX Protocol 4.4 module. protocol.schema : FIX Schema validation module. session : FIXSession module. Classes codec.Codec : Encoding / decoding engine. connection.AsyncFIXConnection : AsyncFIX bidirectional connection. connection.ConnectionRole : Role of the connection INITIATOR / ACCEPTOR. connection.ConnectionState : Connection status enum. connection_client.AsyncFIXClient : Generic FIX client. connection_server.AsyncFIXDummyServer : Simple server which supports only single connection (just for testing). errors.DuplicateSeqNoError : Journaler duplicated seq no written (critical error). errors.DuplicatedTagError : Trying to set tag which is already exist. errors.EncodingError : Codec encoding/decoding error. errors.FIXConnectionError : FIX connection or session error. errors.FIXError : Generic AsyncFIX error. errors.FIXMessageError : FIXMessage related error. errors.RepeatingTagError : Tag was repeated after decoding, indicates mishandled fix group. errors.TagNotFoundError : Requested Tag not present in message. errors.UnmappedRepeatedGrpError : Repeating group improperly set up by protocol. fix_tester.FIXTester : FIX protocol tester. fixtags.FTag : All tags enum. journaler.Journaler : Tracks FIX message history. message.FIXContainer : Generic FIX container. message.FIXMessage : Generic FIXMessage. message.MessageDirection : Direction of the message INBOUND/OUTBOUND. msgtype.FMsg : FIXMessage type enum. common.FExecType : FIX execution report ExecType. common.FOrdSide : FIX Order Side. common.FOrdStatus : FIX Order Status. common.FOrdType : FIX Order Type. order_single.FIXNewOrderSingle : Generic FIXNewOrderSingle wrapper. protocol_base.FIXProtocolBase : Generic FIX protocol. protocol_fix44.FIXProtocol44 : FIXProtocol 4.4 protocol definition class. schema.FIXSchema : FIX schema validator. schema.SchemaComponent : SchemaComponent container. schema.SchemaField : FIX Field schema. schema.SchemaGroup : SchemaGroup container. schema.SchemaHeader : SchemaHeader container. schema.SchemaMessage : SchemaMessage container. schema.SchemaSet : Generic schema set (base for component/group). session.FIXSession : Generic FIX Session container. Functions No functions This file was automatically generated via lazydocs .","title":"API Reference"},{"location":"reference/#api-overview","text":"","title":"API Overview"},{"location":"reference/#modules","text":"codec : FIX Message encoding / decoding module. connection : Abstract connection module. connection_client : FIX Initiator (client) connection. connection_server : Dummy FIX server module. errors : AsyncFIX errors module. fix_tester : FIX Protocol Unit Tester. fixtags : FIX Tags collection module. journaler : Generic SQLite Journaler. message : FIX message and containers module. msgtype : Message type module. protocol : AsyncFIX protocol package. protocol.common : Common FIX protocol enums. protocol.order_single : Generic FIX Order single module. protocol.protocol_base : Base FIX protocol. protocol.protocol_fix44 : FIX Protocol 4.4 module. protocol.schema : FIX Schema validation module. session : FIXSession module.","title":"Modules"},{"location":"reference/#classes","text":"codec.Codec : Encoding / decoding engine. connection.AsyncFIXConnection : AsyncFIX bidirectional connection. connection.ConnectionRole : Role of the connection INITIATOR / ACCEPTOR. connection.ConnectionState : Connection status enum. connection_client.AsyncFIXClient : Generic FIX client. connection_server.AsyncFIXDummyServer : Simple server which supports only single connection (just for testing). errors.DuplicateSeqNoError : Journaler duplicated seq no written (critical error). errors.DuplicatedTagError : Trying to set tag which is already exist. errors.EncodingError : Codec encoding/decoding error. errors.FIXConnectionError : FIX connection or session error. errors.FIXError : Generic AsyncFIX error. errors.FIXMessageError : FIXMessage related error. errors.RepeatingTagError : Tag was repeated after decoding, indicates mishandled fix group. errors.TagNotFoundError : Requested Tag not present in message. errors.UnmappedRepeatedGrpError : Repeating group improperly set up by protocol. fix_tester.FIXTester : FIX protocol tester. fixtags.FTag : All tags enum. journaler.Journaler : Tracks FIX message history. message.FIXContainer : Generic FIX container. message.FIXMessage : Generic FIXMessage. message.MessageDirection : Direction of the message INBOUND/OUTBOUND. msgtype.FMsg : FIXMessage type enum. common.FExecType : FIX execution report ExecType. common.FOrdSide : FIX Order Side. common.FOrdStatus : FIX Order Status. common.FOrdType : FIX Order Type. order_single.FIXNewOrderSingle : Generic FIXNewOrderSingle wrapper. protocol_base.FIXProtocolBase : Generic FIX protocol. protocol_fix44.FIXProtocol44 : FIXProtocol 4.4 protocol definition class. schema.FIXSchema : FIX schema validator. schema.SchemaComponent : SchemaComponent container. schema.SchemaField : FIX Field schema. schema.SchemaGroup : SchemaGroup container. schema.SchemaHeader : SchemaHeader container. schema.SchemaMessage : SchemaMessage container. schema.SchemaSet : Generic schema set (base for component/group). session.FIXSession : Generic FIX Session container.","title":"Classes"},{"location":"reference/#functions","text":"No functions This file was automatically generated via lazydocs .","title":"Functions"},{"location":"reference/codec/","text":"module codec FIX Message encoding / decoding module. class Codec Encoding / decoding engine. Attributes: protocol : FIX protocol SOH : encoded message separator method __init__ __init__(protocol: FIXProtocolBase) Codec init. Args: protocol : FIX protocol used in encoding/decoding method current_datetime current_datetime() \u2192 str FIX complaint date-time string (UTC now). method decode decode( rawmsg: bytes, silent: bool = True ) \u2192 tuple[FIXMessage | None, int, bytes | None] Decodes message from socket. Args: rawmsg : message bytes silent : no errors raised, returns non Returns: if OK - (FIXMessage, bytes_processed, valid_raw_msg_bytes) if ERR - (None, n_bytes_skip, None) method encode encode(msg: FIXMessage, session: FIXSession, raw_seq_num: bool = False) \u2192 str Encodes FIXMessage into serialized message. Args: msg : generic FIXMessage session : current session (for seq num) raw_seq_num : if True - uses MsgSeqNum from msg Returns: encoded message (string) Raises: EncodingError : when failed MsgSeqNum conditions for some types of messages This file was automatically generated via lazydocs .","title":"Codec"},{"location":"reference/codec/#module-codec","text":"FIX Message encoding / decoding module.","title":"module codec"},{"location":"reference/codec/#class-codec","text":"Encoding / decoding engine. Attributes: protocol : FIX protocol SOH : encoded message separator","title":"class Codec"},{"location":"reference/codec/#method-__init__","text":"__init__(protocol: FIXProtocolBase) Codec init. Args: protocol : FIX protocol used in encoding/decoding","title":"method __init__"},{"location":"reference/codec/#method-current_datetime","text":"current_datetime() \u2192 str FIX complaint date-time string (UTC now).","title":"method current_datetime"},{"location":"reference/codec/#method-decode","text":"decode( rawmsg: bytes, silent: bool = True ) \u2192 tuple[FIXMessage | None, int, bytes | None] Decodes message from socket. Args: rawmsg : message bytes silent : no errors raised, returns non Returns: if OK - (FIXMessage, bytes_processed, valid_raw_msg_bytes) if ERR - (None, n_bytes_skip, None)","title":"method decode"},{"location":"reference/codec/#method-encode","text":"encode(msg: FIXMessage, session: FIXSession, raw_seq_num: bool = False) \u2192 str Encodes FIXMessage into serialized message. Args: msg : generic FIXMessage session : current session (for seq num) raw_seq_num : if True - uses MsgSeqNum from msg Returns: encoded message (string) Raises: EncodingError : when failed MsgSeqNum conditions for some types of messages This file was automatically generated via lazydocs .","title":"method encode"},{"location":"reference/connection/","text":"module connection Abstract connection module. class ConnectionState Connection status enum. class ConnectionRole Role of the connection INITIATOR / ACCEPTOR. class AsyncFIXConnection AsyncFIX bidirectional connection. Attributes: connection_state : Current connection_state connection_role : Current connection_role ACCEPTOR | INITIATOR log : logger method __init__ __init__( protocol: FIXProtocolBase, sender_comp_id: str, target_comp_id: str, journaler: Journaler, host: str, port: int, heartbeat_period: int = 30, logger: Logger | None = None ) AsyncFIX bidirectional connection. Args: protocol : FIX protocol sender_comp_id : initiator SenderCompID target_comp_id : acceptor TargetCompID journaler : fix messages journaling engine host : endpoint host port : endpoint port heartbeat_period : heartbeat interval in seconds logger : logger instance (by default logging.getLogger()) start_tasks : True - starts socket/heartbeat asyncio tasks, False - no tasks (this is useful in debugging / testing) property connection_role Current connection role. property connection_state Current connection state. property heartbeat_period Current connection heartbeat period in seconds. property protocol Underlying FIXProtocolBase of a connection. method connect connect() Transport initialization method. method disconnect disconnect(disconn_state: ConnectionState, logout_message: str = None) Disconnect session and closes the socket. Args: disconn_state : connection state after disconnection logout_message : if not None, sends Logout() message to peer with (58=logout_message) method heartbeat_timer_task heartbeat_timer_task() Heartbeat watcher task. method on_connect on_connect() (AppEvent) Underlying socket connected. method on_disconnect on_disconnect() (AppEvent) Underlying socket disconnected. method on_logon on_logon(is_healthy: bool) (AppEvent) Logon(35=A) received from peer. Args: is_healthy : True - if connection_state is ACTIVE method on_logout on_logout(msg: FIXMessage) (AppEvent) Logout(35=5) received from peer. Args: msg : Logout(35=5) FIXMessage method on_message on_message(msg: FIXMessage) (AppEvent) Business message was received. Typically excludes session messages Args: msg : generic incoming FIXMessage method on_state_change on_state_change(connection_state: ConnectionState) (AppEvent) On ConnectionState change. Args: connection_state : new connection state method reset_seq_num reset_seq_num() Resets session and journal seq nums to 1. method send_msg send_msg(msg: FIXMessage) Sends message to the peer. Args: msg : fix message Raises: FIXConnectionError : raised if connection state does not allow sending method send_test_req send_test_req() Sends TestRequest(35=1) and sets TestReqID for expected response from peer. Raises: FIXConnectionError : if another TestRequest() is pending method should_replay should_replay(historical_replay_msg: FIXMessage) \u2192 bool (AppLevel) Checks if historical_replay_msg from Journaler should be replayed. Args: historical_replay_msg : message from Journaler log Returns: True - replay, False - msg skipped (replaced by SequenceReset(35=4)) method socket_read_task socket_read_task() Main socket reader task (decode raw messages and calls _process_message). This file was automatically generated via lazydocs .","title":"Connection"},{"location":"reference/connection/#module-connection","text":"Abstract connection module.","title":"module connection"},{"location":"reference/connection/#class-connectionstate","text":"Connection status enum.","title":"class ConnectionState"},{"location":"reference/connection/#class-connectionrole","text":"Role of the connection INITIATOR / ACCEPTOR.","title":"class ConnectionRole"},{"location":"reference/connection/#class-asyncfixconnection","text":"AsyncFIX bidirectional connection. Attributes: connection_state : Current connection_state connection_role : Current connection_role ACCEPTOR | INITIATOR log : logger","title":"class AsyncFIXConnection"},{"location":"reference/connection/#method-__init__","text":"__init__( protocol: FIXProtocolBase, sender_comp_id: str, target_comp_id: str, journaler: Journaler, host: str, port: int, heartbeat_period: int = 30, logger: Logger | None = None ) AsyncFIX bidirectional connection. Args: protocol : FIX protocol sender_comp_id : initiator SenderCompID target_comp_id : acceptor TargetCompID journaler : fix messages journaling engine host : endpoint host port : endpoint port heartbeat_period : heartbeat interval in seconds logger : logger instance (by default logging.getLogger()) start_tasks : True - starts socket/heartbeat asyncio tasks, False - no tasks (this is useful in debugging / testing)","title":"method __init__"},{"location":"reference/connection/#property-connection_role","text":"Current connection role.","title":"property connection_role"},{"location":"reference/connection/#property-connection_state","text":"Current connection state.","title":"property connection_state"},{"location":"reference/connection/#property-heartbeat_period","text":"Current connection heartbeat period in seconds.","title":"property heartbeat_period"},{"location":"reference/connection/#property-protocol","text":"Underlying FIXProtocolBase of a connection.","title":"property protocol"},{"location":"reference/connection/#method-connect","text":"connect() Transport initialization method.","title":"method connect"},{"location":"reference/connection/#method-disconnect","text":"disconnect(disconn_state: ConnectionState, logout_message: str = None) Disconnect session and closes the socket. Args: disconn_state : connection state after disconnection logout_message : if not None, sends Logout() message to peer with (58=logout_message)","title":"method disconnect"},{"location":"reference/connection/#method-heartbeat_timer_task","text":"heartbeat_timer_task() Heartbeat watcher task.","title":"method heartbeat_timer_task"},{"location":"reference/connection/#method-on_connect","text":"on_connect() (AppEvent) Underlying socket connected.","title":"method on_connect"},{"location":"reference/connection/#method-on_disconnect","text":"on_disconnect() (AppEvent) Underlying socket disconnected.","title":"method on_disconnect"},{"location":"reference/connection/#method-on_logon","text":"on_logon(is_healthy: bool) (AppEvent) Logon(35=A) received from peer. Args: is_healthy : True - if connection_state is ACTIVE","title":"method on_logon"},{"location":"reference/connection/#method-on_logout","text":"on_logout(msg: FIXMessage) (AppEvent) Logout(35=5) received from peer. Args: msg : Logout(35=5) FIXMessage","title":"method on_logout"},{"location":"reference/connection/#method-on_message","text":"on_message(msg: FIXMessage) (AppEvent) Business message was received. Typically excludes session messages Args: msg : generic incoming FIXMessage","title":"method on_message"},{"location":"reference/connection/#method-on_state_change","text":"on_state_change(connection_state: ConnectionState) (AppEvent) On ConnectionState change. Args: connection_state : new connection state","title":"method on_state_change"},{"location":"reference/connection/#method-reset_seq_num","text":"reset_seq_num() Resets session and journal seq nums to 1.","title":"method reset_seq_num"},{"location":"reference/connection/#method-send_msg","text":"send_msg(msg: FIXMessage) Sends message to the peer. Args: msg : fix message Raises: FIXConnectionError : raised if connection state does not allow sending","title":"method send_msg"},{"location":"reference/connection/#method-send_test_req","text":"send_test_req() Sends TestRequest(35=1) and sets TestReqID for expected response from peer. Raises: FIXConnectionError : if another TestRequest() is pending","title":"method send_test_req"},{"location":"reference/connection/#method-should_replay","text":"should_replay(historical_replay_msg: FIXMessage) \u2192 bool (AppLevel) Checks if historical_replay_msg from Journaler should be replayed. Args: historical_replay_msg : message from Journaler log Returns: True - replay, False - msg skipped (replaced by SequenceReset(35=4))","title":"method should_replay"},{"location":"reference/connection/#method-socket_read_task","text":"socket_read_task() Main socket reader task (decode raw messages and calls _process_message). This file was automatically generated via lazydocs .","title":"method socket_read_task"},{"location":"reference/connection_client/","text":"module connection_client FIX Initiator (client) connection. class AsyncFIXClient Generic FIX client. method __init__ __init__( protocol: FIXProtocolBase, sender_comp_id: str, target_comp_id: str, journaler: Journaler, host: str, port: int, heartbeat_period: int = 30, logger: Logger | None = None ) Initialization. Args: protocol : FIX protocol used in codec sender_comp_id : client sender_comp_id tag target_comp_id : client target_comp_id tag journaler : message journaler host : fix host port : fix port heartbeat_period : heartbeat_period in seconds logger : custom logger instance property connection_role Current connection role. property connection_state Current connection state. property heartbeat_period Current connection heartbeat period in seconds. property protocol Underlying FIXProtocolBase of a connection. method connect connect() Connects to the FIX server and initializes session. Raises: FIXConnectionError : if already connected This file was automatically generated via lazydocs .","title":"Connection client"},{"location":"reference/connection_client/#module-connection_client","text":"FIX Initiator (client) connection.","title":"module connection_client"},{"location":"reference/connection_client/#class-asyncfixclient","text":"Generic FIX client.","title":"class AsyncFIXClient"},{"location":"reference/connection_client/#method-__init__","text":"__init__( protocol: FIXProtocolBase, sender_comp_id: str, target_comp_id: str, journaler: Journaler, host: str, port: int, heartbeat_period: int = 30, logger: Logger | None = None ) Initialization. Args: protocol : FIX protocol used in codec sender_comp_id : client sender_comp_id tag target_comp_id : client target_comp_id tag journaler : message journaler host : fix host port : fix port heartbeat_period : heartbeat_period in seconds logger : custom logger instance","title":"method __init__"},{"location":"reference/connection_client/#property-connection_role","text":"Current connection role.","title":"property connection_role"},{"location":"reference/connection_client/#property-connection_state","text":"Current connection state.","title":"property connection_state"},{"location":"reference/connection_client/#property-heartbeat_period","text":"Current connection heartbeat period in seconds.","title":"property heartbeat_period"},{"location":"reference/connection_client/#property-protocol","text":"Underlying FIXProtocolBase of a connection.","title":"property protocol"},{"location":"reference/connection_client/#method-connect","text":"connect() Connects to the FIX server and initializes session. Raises: FIXConnectionError : if already connected This file was automatically generated via lazydocs .","title":"method connect"},{"location":"reference/connection_server/","text":"module connection_server Dummy FIX server module. class AsyncFIXDummyServer Simple server which supports only single connection (just for testing). method __init__ __init__( protocol: FIXProtocolBase, sender_comp_id: str, target_comp_id: str, journaler: Journaler, host: str, port: int, heartbeat_period: int = 30, logger: Logger | None = None ) Initialization. Args: protocol : FIX protocol used in codec sender_comp_id : server sender_comp_id tag target_comp_id : server target_comp_id tag journaler : message journaler host : fix host to listen port : fix port to bind heartbeat_period : heartbeat_period in seconds logger : custom logger instance property connection_role Current connection role. property connection_state Current connection state. property heartbeat_period Current connection heartbeat period in seconds. property protocol Underlying FIXProtocolBase of a connection. method connect connect() Starts the server and infinitely runs it. Raises: FIXConnectionError : when already connected This file was automatically generated via lazydocs .","title":"Connection server"},{"location":"reference/connection_server/#module-connection_server","text":"Dummy FIX server module.","title":"module connection_server"},{"location":"reference/connection_server/#class-asyncfixdummyserver","text":"Simple server which supports only single connection (just for testing).","title":"class AsyncFIXDummyServer"},{"location":"reference/connection_server/#method-__init__","text":"__init__( protocol: FIXProtocolBase, sender_comp_id: str, target_comp_id: str, journaler: Journaler, host: str, port: int, heartbeat_period: int = 30, logger: Logger | None = None ) Initialization. Args: protocol : FIX protocol used in codec sender_comp_id : server sender_comp_id tag target_comp_id : server target_comp_id tag journaler : message journaler host : fix host to listen port : fix port to bind heartbeat_period : heartbeat_period in seconds logger : custom logger instance","title":"method __init__"},{"location":"reference/connection_server/#property-connection_role","text":"Current connection role.","title":"property connection_role"},{"location":"reference/connection_server/#property-connection_state","text":"Current connection state.","title":"property connection_state"},{"location":"reference/connection_server/#property-heartbeat_period","text":"Current connection heartbeat period in seconds.","title":"property heartbeat_period"},{"location":"reference/connection_server/#property-protocol","text":"Underlying FIXProtocolBase of a connection.","title":"property protocol"},{"location":"reference/connection_server/#method-connect","text":"connect() Starts the server and infinitely runs it. Raises: FIXConnectionError : when already connected This file was automatically generated via lazydocs .","title":"method connect"},{"location":"reference/errors/","text":"module errors AsyncFIX errors module. class FIXError Generic AsyncFIX error. class FIXMessageError FIXMessage related error. class FIXConnectionError FIX connection or session error. class DuplicateSeqNoError Journaler duplicated seq no written (critical error). class EncodingError Codec encoding/decoding error. class TagNotFoundError Requested Tag not present in message. class DuplicatedTagError Trying to set tag which is already exist. class RepeatingTagError Tag was repeated after decoding, indicates mishandled fix group. class UnmappedRepeatedGrpError Repeating group improperly set up by protocol. This file was automatically generated via lazydocs .","title":"Errors"},{"location":"reference/errors/#module-errors","text":"AsyncFIX errors module.","title":"module errors"},{"location":"reference/errors/#class-fixerror","text":"Generic AsyncFIX error.","title":"class FIXError"},{"location":"reference/errors/#class-fixmessageerror","text":"FIXMessage related error.","title":"class FIXMessageError"},{"location":"reference/errors/#class-fixconnectionerror","text":"FIX connection or session error.","title":"class FIXConnectionError"},{"location":"reference/errors/#class-duplicateseqnoerror","text":"Journaler duplicated seq no written (critical error).","title":"class DuplicateSeqNoError"},{"location":"reference/errors/#class-encodingerror","text":"Codec encoding/decoding error.","title":"class EncodingError"},{"location":"reference/errors/#class-tagnotfounderror","text":"Requested Tag not present in message.","title":"class TagNotFoundError"},{"location":"reference/errors/#class-duplicatedtagerror","text":"Trying to set tag which is already exist.","title":"class DuplicatedTagError"},{"location":"reference/errors/#class-repeatingtagerror","text":"Tag was repeated after decoding, indicates mishandled fix group.","title":"class RepeatingTagError"},{"location":"reference/errors/#class-unmappedrepeatedgrperror","text":"Repeating group improperly set up by protocol. This file was automatically generated via lazydocs .","title":"class UnmappedRepeatedGrpError"},{"location":"reference/fix_tester/","text":"module fix_tester FIX Protocol Unit Tester. Global Variables nan class FIXTester FIX protocol tester. Attributes: registered_orders : registered orders (sent via FIXTester) schema : fix schema for validation (optional) conn_init : fix connection initiator conn_accept : fix virtual acceptor (simulated by FIXTester) initiator_sent : messages sent by initiator acceptor_rcv_que : raw messages received by (simulated acceptor) acceptor_sent : FIXMessages sent by simulated acceptor method __init__ __init__( schema: FIXSchema | None = None, connection: AsyncFIXConnection | None = None ) Initialize FIXTester. Args: schema : (optional) FIXSchema for validating incoming/outgoing messages connection : (optional) fix initiator connection method acceptor_sent_query acceptor_sent_query( tags: tuple[FTag | str | int] | None = None, index: int = -1 ) \u2192 dict[FTag | str, str] Query message sent from FIXTester to initiator. Args: tags : tuple of tag numbers index : index of self.acceptor_sent list, default -1 Returns: dict {FTag.MsgSeqNum : \"34\", \"12382\": \"some value\"} method fix_cxl_request fix_cxl_request(o: FIXNewOrderSingle) \u2192 FIXMessage Generates FIXNewOrderSingle cancel request + optional validation. Returns: cancel FIXMessage method fix_cxlrep_reject_msg fix_cxlrep_reject_msg(cxl_req: FIXMessage, ord_status: FOrdStatus) \u2192 FIXMessage Generates synthetic ORDERCANCELREJECT message. Args: cxl_req : cancel / replace request FIXMessage (from initiator) ord_status : new order status generated by this reply Returns: ORDERCANCELREJECT FIXMessage method fix_exec_report_msg fix_exec_report_msg( order: FIXNewOrderSingle, clord_id: str, exec_type: FExecType, ord_status: FOrdStatus, cum_qty: float = nan, leaves_qty: float = nan, last_qty: float = nan, price: float = nan, order_qty: float = nan, orig_clord_id: str = None, avg_price: float = 0.0 ) \u2192 FIXMessage Generates synthetic EXECUTIONREPORT. Args: order : FIXNewOrderSingle to report clord_id : report ClOrdID tag exec_type : report ExecType ord_status : report FOrdStatus cum_qty : filled qty leaves_qty : remaining qty last_qty : last trade qty price : (ONLY IN REPLACE) price of replaced order order_qty : (ONLY IN REPLACE) qty of replaced order orig_clord_id : report OrigClOrdID avg_price : average fill price Returns: EXECUTIONREPORT FIXMessage method fix_rep_request fix_rep_request( o: FIXNewOrderSingle, price: float = nan, qty: float = nan ) \u2192 FIXMessage Generates FIXNewOrderSingle replace request + optional validating. Args: o : FIXNewOrderSingle price : new price, nan - to skip qty : new quantity, nan - to skip Returns: replace FIXMessage method initiator_sent_query initiator_sent_query( tags: tuple[FTag | str | int] | None = None, index: int = -1 ) \u2192 dict[FTag | str, str] Query message sent from initiator to FixTester. Args: tags : tuple of tag numbers index : index of self.initiator_sent list, default -1 Returns: dict {FTag.MsgSeqNum : \"34\", \"12382\": \"some value\"} method msg_heartbeat msg_heartbeat(test_req_id=None) \u2192 FIXMessage Generates message HEARTBEAT + schema validation. Args: test_req_id : if Heartbeat in reply to TESTREQUEST method msg_logon msg_logon(tags: dict | None = None) \u2192 FIXMessage Generates message LOGON + schema validation. Args: tags : extra tags Returns: FIXMessage method msg_logout msg_logout() \u2192 FIXMessage Generates message LOGOUT + schema validation. method msg_resend_request msg_resend_request(begin_seq_no, end_seq_no='0') \u2192 FIXMessage Generates message RESENDREQUEST + schema validation. Args: begin_seq_no : seq no to start with end_seq_no : end seq no, \"0\" - means all method msg_sequence_reset msg_sequence_reset( msg_seq_num: int, new_seq_no: int, is_gap_fill: bool = False ) \u2192 FIXMessage Generates message SEQUENCERESET + schema validation. Args: msg_seq_num : FTag.MsgSeqNum value new_seq_no : FTag.NewSeqNo value is_gap_fill : FTag.GapFillFlag \"Y\"/\"N\" method msg_test_request msg_test_request(test_req_id) \u2192 FIXMessage Generates message TESTREQUEST + schema validation. Args: test_req_id : unique test request id method order_register_single order_register_single(o: FIXNewOrderSingle) Registers FIXNewOrderSingle. method process_msg_acceptor process_msg_acceptor(index=None) Processes messages queued by initiator.send_msg(). Args: index : None - processes all messages in que, number - only one at that index method reply reply(msg: FIXMessage) Manually reply to the initiator with arbitrary FIXMessage. Args: msg : arbitrary FIXMessage method reset_messages reset_messages() Reset messages queues of initiator and acceptor. method set_next_num set_next_num(num_in=None, num_out=None) Set expected session seq nums for simulated acceptor. Args: num_in : next num in expected by simulated acceptor num_out : next num out sent by simulated acceptor This file was automatically generated via lazydocs .","title":"Fix tester"},{"location":"reference/fix_tester/#module-fix_tester","text":"FIX Protocol Unit Tester.","title":"module fix_tester"},{"location":"reference/fix_tester/#global-variables","text":"nan","title":"Global Variables"},{"location":"reference/fix_tester/#class-fixtester","text":"FIX protocol tester. Attributes: registered_orders : registered orders (sent via FIXTester) schema : fix schema for validation (optional) conn_init : fix connection initiator conn_accept : fix virtual acceptor (simulated by FIXTester) initiator_sent : messages sent by initiator acceptor_rcv_que : raw messages received by (simulated acceptor) acceptor_sent : FIXMessages sent by simulated acceptor","title":"class FIXTester"},{"location":"reference/fix_tester/#method-__init__","text":"__init__( schema: FIXSchema | None = None, connection: AsyncFIXConnection | None = None ) Initialize FIXTester. Args: schema : (optional) FIXSchema for validating incoming/outgoing messages connection : (optional) fix initiator connection","title":"method __init__"},{"location":"reference/fix_tester/#method-acceptor_sent_query","text":"acceptor_sent_query( tags: tuple[FTag | str | int] | None = None, index: int = -1 ) \u2192 dict[FTag | str, str] Query message sent from FIXTester to initiator. Args: tags : tuple of tag numbers index : index of self.acceptor_sent list, default -1 Returns: dict {FTag.MsgSeqNum : \"34\", \"12382\": \"some value\"}","title":"method acceptor_sent_query"},{"location":"reference/fix_tester/#method-fix_cxl_request","text":"fix_cxl_request(o: FIXNewOrderSingle) \u2192 FIXMessage Generates FIXNewOrderSingle cancel request + optional validation. Returns: cancel FIXMessage","title":"method fix_cxl_request"},{"location":"reference/fix_tester/#method-fix_cxlrep_reject_msg","text":"fix_cxlrep_reject_msg(cxl_req: FIXMessage, ord_status: FOrdStatus) \u2192 FIXMessage Generates synthetic ORDERCANCELREJECT message. Args: cxl_req : cancel / replace request FIXMessage (from initiator) ord_status : new order status generated by this reply Returns: ORDERCANCELREJECT FIXMessage","title":"method fix_cxlrep_reject_msg"},{"location":"reference/fix_tester/#method-fix_exec_report_msg","text":"fix_exec_report_msg( order: FIXNewOrderSingle, clord_id: str, exec_type: FExecType, ord_status: FOrdStatus, cum_qty: float = nan, leaves_qty: float = nan, last_qty: float = nan, price: float = nan, order_qty: float = nan, orig_clord_id: str = None, avg_price: float = 0.0 ) \u2192 FIXMessage Generates synthetic EXECUTIONREPORT. Args: order : FIXNewOrderSingle to report clord_id : report ClOrdID tag exec_type : report ExecType ord_status : report FOrdStatus cum_qty : filled qty leaves_qty : remaining qty last_qty : last trade qty price : (ONLY IN REPLACE) price of replaced order order_qty : (ONLY IN REPLACE) qty of replaced order orig_clord_id : report OrigClOrdID avg_price : average fill price Returns: EXECUTIONREPORT FIXMessage","title":"method fix_exec_report_msg"},{"location":"reference/fix_tester/#method-fix_rep_request","text":"fix_rep_request( o: FIXNewOrderSingle, price: float = nan, qty: float = nan ) \u2192 FIXMessage Generates FIXNewOrderSingle replace request + optional validating. Args: o : FIXNewOrderSingle price : new price, nan - to skip qty : new quantity, nan - to skip Returns: replace FIXMessage","title":"method fix_rep_request"},{"location":"reference/fix_tester/#method-initiator_sent_query","text":"initiator_sent_query( tags: tuple[FTag | str | int] | None = None, index: int = -1 ) \u2192 dict[FTag | str, str] Query message sent from initiator to FixTester. Args: tags : tuple of tag numbers index : index of self.initiator_sent list, default -1 Returns: dict {FTag.MsgSeqNum : \"34\", \"12382\": \"some value\"}","title":"method initiator_sent_query"},{"location":"reference/fix_tester/#method-msg_heartbeat","text":"msg_heartbeat(test_req_id=None) \u2192 FIXMessage Generates message HEARTBEAT + schema validation. Args: test_req_id : if Heartbeat in reply to TESTREQUEST","title":"method msg_heartbeat"},{"location":"reference/fix_tester/#method-msg_logon","text":"msg_logon(tags: dict | None = None) \u2192 FIXMessage Generates message LOGON + schema validation. Args: tags : extra tags Returns: FIXMessage","title":"method msg_logon"},{"location":"reference/fix_tester/#method-msg_logout","text":"msg_logout() \u2192 FIXMessage Generates message LOGOUT + schema validation.","title":"method msg_logout"},{"location":"reference/fix_tester/#method-msg_resend_request","text":"msg_resend_request(begin_seq_no, end_seq_no='0') \u2192 FIXMessage Generates message RESENDREQUEST + schema validation. Args: begin_seq_no : seq no to start with end_seq_no : end seq no, \"0\" - means all","title":"method msg_resend_request"},{"location":"reference/fix_tester/#method-msg_sequence_reset","text":"msg_sequence_reset( msg_seq_num: int, new_seq_no: int, is_gap_fill: bool = False ) \u2192 FIXMessage Generates message SEQUENCERESET + schema validation. Args: msg_seq_num : FTag.MsgSeqNum value new_seq_no : FTag.NewSeqNo value is_gap_fill : FTag.GapFillFlag \"Y\"/\"N\"","title":"method msg_sequence_reset"},{"location":"reference/fix_tester/#method-msg_test_request","text":"msg_test_request(test_req_id) \u2192 FIXMessage Generates message TESTREQUEST + schema validation. Args: test_req_id : unique test request id","title":"method msg_test_request"},{"location":"reference/fix_tester/#method-order_register_single","text":"order_register_single(o: FIXNewOrderSingle) Registers FIXNewOrderSingle.","title":"method order_register_single"},{"location":"reference/fix_tester/#method-process_msg_acceptor","text":"process_msg_acceptor(index=None) Processes messages queued by initiator.send_msg(). Args: index : None - processes all messages in que, number - only one at that index","title":"method process_msg_acceptor"},{"location":"reference/fix_tester/#method-reply","text":"reply(msg: FIXMessage) Manually reply to the initiator with arbitrary FIXMessage. Args: msg : arbitrary FIXMessage","title":"method reply"},{"location":"reference/fix_tester/#method-reset_messages","text":"reset_messages() Reset messages queues of initiator and acceptor.","title":"method reset_messages"},{"location":"reference/fix_tester/#method-set_next_num","text":"set_next_num(num_in=None, num_out=None) Set expected session seq nums for simulated acceptor. Args: num_in : next num in expected by simulated acceptor num_out : next num out sent by simulated acceptor This file was automatically generated via lazydocs .","title":"method set_next_num"},{"location":"reference/fixtags/","text":"module fixtags FIX Tags collection module. class FTag All tags enum. This file was automatically generated via lazydocs .","title":"Fixtags"},{"location":"reference/fixtags/#module-fixtags","text":"FIX Tags collection module.","title":"module fixtags"},{"location":"reference/fixtags/#class-ftag","text":"All tags enum. This file was automatically generated via lazydocs .","title":"class FTag"},{"location":"reference/journaler/","text":"module journaler Generic SQLite Journaler. class Journaler Tracks FIX message history. method __init__ __init__(filename=None) Initialize SQLite Journaler. Args: filename : path to file, or None - to make in-memory journal method create_or_load create_or_load(target_comp_id, sender_comp_id) \u2192 FIXSession Creates or loads new session with unique target_comp_id/sender_comp_id. Args: target_comp_id : session targetCompId sender_comp_id : session senderCompId Returns: FIXSession method find_seq_no find_seq_no(msg: bytes) \u2192 int Finds 34= in serialized message. Args: msg : encoded fix message Returns: seq no value Raises: FIXMessageError : if not found or malformed message method get_all_msgs get_all_msgs( sessions: list[FIXSession] | None = None, direction: MessageDirection | None = None ) Get all messages from the Journaler DB. Args: sessions : session filter (optional) direction : direction filter (optional) Returns: list of tuples [(seq_no, enc_msg, direction, session_key), ...] method persist_msg persist_msg(msg: bytes, session: FIXSession, direction: MessageDirection) Commits encoded fix message into DB. Args: msg : encoded fix message session : target session direction : message direction Raises: DuplicateSeqNoError : (critical) when DB already have such message seq_no method recover_messages recover_messages( session: FIXSession, direction: MessageDirection, start_seq_no: int | str, end_seq_no: int | str ) \u2192 list[bytes] Loads messages with seq no range from DB. Args: session : target session direction : message direction start_seq_no : seq no from end_seq_no : seq no to Returns: list of encoded FIX messages method recover_msg recover_msg( session: FIXSession, direction: MessageDirection, seq_no: int ) \u2192 bytes Loads specific message from DB by seq no. Args: session : target session direction : message direction seq_no : target seq_no Returns: encoded message (bytes) method sessions sessions() \u2192 dict[tuple[str, str], FIXSession] Loads all available sessions from journal. method set_seq_num set_seq_num( session: FIXSession, next_num_out: int | None = None, next_num_in: int | None = None ) Sets journal and session seq num. Args: session : target session next_num_out : new expected num out (optional) next_num_in : new expected num in (optional) This file was automatically generated via lazydocs .","title":"Journaler"},{"location":"reference/journaler/#module-journaler","text":"Generic SQLite Journaler.","title":"module journaler"},{"location":"reference/journaler/#class-journaler","text":"Tracks FIX message history.","title":"class Journaler"},{"location":"reference/journaler/#method-__init__","text":"__init__(filename=None) Initialize SQLite Journaler. Args: filename : path to file, or None - to make in-memory journal","title":"method __init__"},{"location":"reference/journaler/#method-create_or_load","text":"create_or_load(target_comp_id, sender_comp_id) \u2192 FIXSession Creates or loads new session with unique target_comp_id/sender_comp_id. Args: target_comp_id : session targetCompId sender_comp_id : session senderCompId Returns: FIXSession","title":"method create_or_load"},{"location":"reference/journaler/#method-find_seq_no","text":"find_seq_no(msg: bytes) \u2192 int Finds 34= in serialized message. Args: msg : encoded fix message Returns: seq no value Raises: FIXMessageError : if not found or malformed message","title":"method find_seq_no"},{"location":"reference/journaler/#method-get_all_msgs","text":"get_all_msgs( sessions: list[FIXSession] | None = None, direction: MessageDirection | None = None ) Get all messages from the Journaler DB. Args: sessions : session filter (optional) direction : direction filter (optional) Returns: list of tuples [(seq_no, enc_msg, direction, session_key), ...]","title":"method get_all_msgs"},{"location":"reference/journaler/#method-persist_msg","text":"persist_msg(msg: bytes, session: FIXSession, direction: MessageDirection) Commits encoded fix message into DB. Args: msg : encoded fix message session : target session direction : message direction Raises: DuplicateSeqNoError : (critical) when DB already have such message seq_no","title":"method persist_msg"},{"location":"reference/journaler/#method-recover_messages","text":"recover_messages( session: FIXSession, direction: MessageDirection, start_seq_no: int | str, end_seq_no: int | str ) \u2192 list[bytes] Loads messages with seq no range from DB. Args: session : target session direction : message direction start_seq_no : seq no from end_seq_no : seq no to Returns: list of encoded FIX messages","title":"method recover_messages"},{"location":"reference/journaler/#method-recover_msg","text":"recover_msg( session: FIXSession, direction: MessageDirection, seq_no: int ) \u2192 bytes Loads specific message from DB by seq no. Args: session : target session direction : message direction seq_no : target seq_no Returns: encoded message (bytes)","title":"method recover_msg"},{"location":"reference/journaler/#method-sessions","text":"sessions() \u2192 dict[tuple[str, str], FIXSession] Loads all available sessions from journal.","title":"method sessions"},{"location":"reference/journaler/#method-set_seq_num","text":"set_seq_num( session: FIXSession, next_num_out: int | None = None, next_num_in: int | None = None ) Sets journal and session seq num. Args: session : target session next_num_out : new expected num out (optional) next_num_in : new expected num in (optional) This file was automatically generated via lazydocs .","title":"method set_seq_num"},{"location":"reference/message/","text":"module message FIX message and containers module. class MessageDirection Direction of the message INBOUND/OUTBOUND. class FIXContainer Generic FIX container. Attributes: tags : fix tags of the container method __init__ __init__( tags: 'dict[str | int, [str, float, int, list[dict | FIXContainer]]]' = None ) Initialize. Examples: m = FIXContainer({ 1: \"account\", FTag.ClOrdID: 'my-clord', FTag.NoAllocs: [{312: 'grp1'}, {312: 'grp2'}], }) Args: tags : add tags at initialization time (all keys / values converted to str!) method add_group add_group(tag: 'str | int', group: 'FIXContainer | dict', index: 'int' = -1) Add repeating group item to fix message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs group : group item (another FIXContainer) or dict[tag: value] index : where to insert new value, default: append Raises: FIXMessageError : incorrect group type/value method get get( tag: 'str | int | FTag', default=<class 'asyncfix.errors.TagNotFoundError'> ) \u2192 str Get tag value. Args: tag : tag to get default : default value or raises TagNotFoundError Returns: string value of the tag Raises: FIXMessageError : trying to get FIX message group by tag, use get_group() RepeatingTagError : tag was repeated in decoded message, probably msg group TagNotFoundError : tag was not found in message method get_group_by_index get_group_by_index(tag: 'str | int', index: 'int') \u2192 FIXContainer Get repeating group item by index. Args: tag : repeating group tag index : repeating group item index Returns: FIXContainer Raises: TagNotFoundError : tag not found method get_group_by_tag get_group_by_tag( tag: 'str | int', gtag: 'str | int', gvalue: 'str' ) \u2192 FIXContainer Get repeating group item by internal group tag value. Args: tag : repeating group tag gtag : inside group tag to filter by gvalue : expected group tag value Returns: FIXContainer of repeating group item Raises: TagNotFoundError : tag not found method get_group_list get_group_list(tag: 'str | int') \u2192 list[FIXContainer] Get all repeating groups of a tag. Args: tag : target tag Returns: list of repeating FIXContainers Raises: UnmappedRepeatedGrpError : repeating group is not handled by protocol class TagNotFoundError : tag not found method is_group is_group(tag: 'str | int') \u2192 bool | None Check if tag is repeating group. Args: tag : tag to check Returns: None - if not found True - if repeating group False - simple tag method items items() All tags items iterator. method query query(*tags: 'tuple[FTag | str | int]') \u2192 dict[FTag | str, str] Request multiple tags from FIXMessage as dictionary. Args: *tags : tags var arguments Returns: dict {tag : value, ...} method set set(tag: 'str | int', value, replace: 'bool' = False) Set tag value. Args: tag : tag to set value : value to set (converted to str!) replace : set True - to intentionally rewrite existing tag Raises: DuplicatedTagError : when trying to set existing tag FIXMessageError : tag value is not convertible to int method set_group set_group(tag: 'str | int', groups: 'list[dict, FIXContainer]') Set repeating groups of the message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs groups : group items list of (another FIXContainer) or dict[tag: value] Raises: DuplicatedTagError : group with the same tag already exists FIXMessageError : incorrect group type/value class FIXMessage Generic FIXMessage. method __init__ __init__( msg_type: 'str | FMsg', tags: 'dict[str | int, [str, float, int]]' = None ) Initialize. Args: msg_type : message type, must comply with FIXTag=35 tags : initial tags values property msg_type Message type. method add_group add_group(tag: 'str | int', group: 'FIXContainer | dict', index: 'int' = -1) Add repeating group item to fix message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs group : group item (another FIXContainer) or dict[tag: value] index : where to insert new value, default: append Raises: FIXMessageError : incorrect group type/value method get get( tag: 'str | int | FTag', default=<class 'asyncfix.errors.TagNotFoundError'> ) \u2192 str Get tag value. Args: tag : tag to get default : default value or raises TagNotFoundError Returns: string value of the tag Raises: FIXMessageError : trying to get FIX message group by tag, use get_group() RepeatingTagError : tag was repeated in decoded message, probably msg group TagNotFoundError : tag was not found in message method get_group_by_index get_group_by_index(tag: 'str | int', index: 'int') \u2192 FIXContainer Get repeating group item by index. Args: tag : repeating group tag index : repeating group item index Returns: FIXContainer Raises: TagNotFoundError : tag not found method get_group_by_tag get_group_by_tag( tag: 'str | int', gtag: 'str | int', gvalue: 'str' ) \u2192 FIXContainer Get repeating group item by internal group tag value. Args: tag : repeating group tag gtag : inside group tag to filter by gvalue : expected group tag value Returns: FIXContainer of repeating group item Raises: TagNotFoundError : tag not found method get_group_list get_group_list(tag: 'str | int') \u2192 list[FIXContainer] Get all repeating groups of a tag. Args: tag : target tag Returns: list of repeating FIXContainers Raises: UnmappedRepeatedGrpError : repeating group is not handled by protocol class TagNotFoundError : tag not found method is_group is_group(tag: 'str | int') \u2192 bool | None Check if tag is repeating group. Args: tag : tag to check Returns: None - if not found True - if repeating group False - simple tag method items items() All tags items iterator. method query query(*tags: 'tuple[FTag | str | int]') \u2192 dict[FTag | str, str] Request multiple tags from FIXMessage as dictionary. Args: *tags : tags var arguments Returns: dict {tag : value, ...} method set set(tag: 'str | int', value, replace: 'bool' = False) Set tag value. Args: tag : tag to set value : value to set (converted to str!) replace : set True - to intentionally rewrite existing tag Raises: DuplicatedTagError : when trying to set existing tag FIXMessageError : tag value is not convertible to int method set_group set_group(tag: 'str | int', groups: 'list[dict, FIXContainer]') Set repeating groups of the message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs groups : group items list of (another FIXContainer) or dict[tag: value] Raises: DuplicatedTagError : group with the same tag already exists FIXMessageError : incorrect group type/value This file was automatically generated via lazydocs .","title":"Message"},{"location":"reference/message/#module-message","text":"FIX message and containers module.","title":"module message"},{"location":"reference/message/#class-messagedirection","text":"Direction of the message INBOUND/OUTBOUND.","title":"class MessageDirection"},{"location":"reference/message/#class-fixcontainer","text":"Generic FIX container. Attributes: tags : fix tags of the container","title":"class FIXContainer"},{"location":"reference/message/#method-__init__","text":"__init__( tags: 'dict[str | int, [str, float, int, list[dict | FIXContainer]]]' = None ) Initialize. Examples: m = FIXContainer({ 1: \"account\", FTag.ClOrdID: 'my-clord', FTag.NoAllocs: [{312: 'grp1'}, {312: 'grp2'}], }) Args: tags : add tags at initialization time (all keys / values converted to str!)","title":"method __init__"},{"location":"reference/message/#method-add_group","text":"add_group(tag: 'str | int', group: 'FIXContainer | dict', index: 'int' = -1) Add repeating group item to fix message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs group : group item (another FIXContainer) or dict[tag: value] index : where to insert new value, default: append Raises: FIXMessageError : incorrect group type/value","title":"method add_group"},{"location":"reference/message/#method-get","text":"get( tag: 'str | int | FTag', default=<class 'asyncfix.errors.TagNotFoundError'> ) \u2192 str Get tag value. Args: tag : tag to get default : default value or raises TagNotFoundError Returns: string value of the tag Raises: FIXMessageError : trying to get FIX message group by tag, use get_group() RepeatingTagError : tag was repeated in decoded message, probably msg group TagNotFoundError : tag was not found in message","title":"method get"},{"location":"reference/message/#method-get_group_by_index","text":"get_group_by_index(tag: 'str | int', index: 'int') \u2192 FIXContainer Get repeating group item by index. Args: tag : repeating group tag index : repeating group item index Returns: FIXContainer Raises: TagNotFoundError : tag not found","title":"method get_group_by_index"},{"location":"reference/message/#method-get_group_by_tag","text":"get_group_by_tag( tag: 'str | int', gtag: 'str | int', gvalue: 'str' ) \u2192 FIXContainer Get repeating group item by internal group tag value. Args: tag : repeating group tag gtag : inside group tag to filter by gvalue : expected group tag value Returns: FIXContainer of repeating group item Raises: TagNotFoundError : tag not found","title":"method get_group_by_tag"},{"location":"reference/message/#method-get_group_list","text":"get_group_list(tag: 'str | int') \u2192 list[FIXContainer] Get all repeating groups of a tag. Args: tag : target tag Returns: list of repeating FIXContainers Raises: UnmappedRepeatedGrpError : repeating group is not handled by protocol class TagNotFoundError : tag not found","title":"method get_group_list"},{"location":"reference/message/#method-is_group","text":"is_group(tag: 'str | int') \u2192 bool | None Check if tag is repeating group. Args: tag : tag to check Returns: None - if not found True - if repeating group False - simple tag","title":"method is_group"},{"location":"reference/message/#method-items","text":"items() All tags items iterator.","title":"method items"},{"location":"reference/message/#method-query","text":"query(*tags: 'tuple[FTag | str | int]') \u2192 dict[FTag | str, str] Request multiple tags from FIXMessage as dictionary. Args: *tags : tags var arguments Returns: dict {tag : value, ...}","title":"method query"},{"location":"reference/message/#method-set","text":"set(tag: 'str | int', value, replace: 'bool' = False) Set tag value. Args: tag : tag to set value : value to set (converted to str!) replace : set True - to intentionally rewrite existing tag Raises: DuplicatedTagError : when trying to set existing tag FIXMessageError : tag value is not convertible to int","title":"method set"},{"location":"reference/message/#method-set_group","text":"set_group(tag: 'str | int', groups: 'list[dict, FIXContainer]') Set repeating groups of the message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs groups : group items list of (another FIXContainer) or dict[tag: value] Raises: DuplicatedTagError : group with the same tag already exists FIXMessageError : incorrect group type/value","title":"method set_group"},{"location":"reference/message/#class-fixmessage","text":"Generic FIXMessage.","title":"class FIXMessage"},{"location":"reference/message/#method-__init___1","text":"__init__( msg_type: 'str | FMsg', tags: 'dict[str | int, [str, float, int]]' = None ) Initialize. Args: msg_type : message type, must comply with FIXTag=35 tags : initial tags values","title":"method __init__"},{"location":"reference/message/#property-msg_type","text":"Message type.","title":"property msg_type"},{"location":"reference/message/#method-add_group_1","text":"add_group(tag: 'str | int', group: 'FIXContainer | dict', index: 'int' = -1) Add repeating group item to fix message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs group : group item (another FIXContainer) or dict[tag: value] index : where to insert new value, default: append Raises: FIXMessageError : incorrect group type/value","title":"method add_group"},{"location":"reference/message/#method-get_1","text":"get( tag: 'str | int | FTag', default=<class 'asyncfix.errors.TagNotFoundError'> ) \u2192 str Get tag value. Args: tag : tag to get default : default value or raises TagNotFoundError Returns: string value of the tag Raises: FIXMessageError : trying to get FIX message group by tag, use get_group() RepeatingTagError : tag was repeated in decoded message, probably msg group TagNotFoundError : tag was not found in message","title":"method get"},{"location":"reference/message/#method-get_group_by_index_1","text":"get_group_by_index(tag: 'str | int', index: 'int') \u2192 FIXContainer Get repeating group item by index. Args: tag : repeating group tag index : repeating group item index Returns: FIXContainer Raises: TagNotFoundError : tag not found","title":"method get_group_by_index"},{"location":"reference/message/#method-get_group_by_tag_1","text":"get_group_by_tag( tag: 'str | int', gtag: 'str | int', gvalue: 'str' ) \u2192 FIXContainer Get repeating group item by internal group tag value. Args: tag : repeating group tag gtag : inside group tag to filter by gvalue : expected group tag value Returns: FIXContainer of repeating group item Raises: TagNotFoundError : tag not found","title":"method get_group_by_tag"},{"location":"reference/message/#method-get_group_list_1","text":"get_group_list(tag: 'str | int') \u2192 list[FIXContainer] Get all repeating groups of a tag. Args: tag : target tag Returns: list of repeating FIXContainers Raises: UnmappedRepeatedGrpError : repeating group is not handled by protocol class TagNotFoundError : tag not found","title":"method get_group_list"},{"location":"reference/message/#method-is_group_1","text":"is_group(tag: 'str | int') \u2192 bool | None Check if tag is repeating group. Args: tag : tag to check Returns: None - if not found True - if repeating group False - simple tag","title":"method is_group"},{"location":"reference/message/#method-items_1","text":"items() All tags items iterator.","title":"method items"},{"location":"reference/message/#method-query_1","text":"query(*tags: 'tuple[FTag | str | int]') \u2192 dict[FTag | str, str] Request multiple tags from FIXMessage as dictionary. Args: *tags : tags var arguments Returns: dict {tag : value, ...}","title":"method query"},{"location":"reference/message/#method-set_1","text":"set(tag: 'str | int', value, replace: 'bool' = False) Set tag value. Args: tag : tag to set value : value to set (converted to str!) replace : set True - to intentionally rewrite existing tag Raises: DuplicatedTagError : when trying to set existing tag FIXMessageError : tag value is not convertible to int","title":"method set"},{"location":"reference/message/#method-set_group_1","text":"set_group(tag: 'str | int', groups: 'list[dict, FIXContainer]') Set repeating groups of the message. Args: tag : tag of repeating group, typically contains No , e.g. FTag.NoAllocs groups : group items list of (another FIXContainer) or dict[tag: value] Raises: DuplicatedTagError : group with the same tag already exists FIXMessageError : incorrect group type/value This file was automatically generated via lazydocs .","title":"method set_group"},{"location":"reference/msgtype/","text":"module msgtype Message type module. class FMsg FIXMessage type enum. This file was automatically generated via lazydocs .","title":"Msgtype"},{"location":"reference/msgtype/#module-msgtype","text":"Message type module.","title":"module msgtype"},{"location":"reference/msgtype/#class-fmsg","text":"FIXMessage type enum. This file was automatically generated via lazydocs .","title":"class FMsg"},{"location":"reference/protocol.common/","text":"module protocol.common Common FIX protocol enums. class FOrdSide FIX Order Side. class FOrdType FIX Order Type. class FOrdStatus FIX Order Status. class FExecType FIX execution report ExecType. This file was automatically generated via lazydocs .","title":"Protocol.common"},{"location":"reference/protocol.common/#module-protocolcommon","text":"Common FIX protocol enums.","title":"module protocol.common"},{"location":"reference/protocol.common/#class-fordside","text":"FIX Order Side.","title":"class FOrdSide"},{"location":"reference/protocol.common/#class-fordtype","text":"FIX Order Type.","title":"class FOrdType"},{"location":"reference/protocol.common/#class-fordstatus","text":"FIX Order Status.","title":"class FOrdStatus"},{"location":"reference/protocol.common/#class-fexectype","text":"FIX execution report ExecType. This file was automatically generated via lazydocs .","title":"class FExecType"},{"location":"reference/protocol/","text":"module protocol AsyncFIX protocol package. Global Variables protocol_base protocol_fix44 schema common order_single This file was automatically generated via lazydocs .","title":"Protocol"},{"location":"reference/protocol/#module-protocol","text":"AsyncFIX protocol package.","title":"module protocol"},{"location":"reference/protocol/#global-variables","text":"protocol_base protocol_fix44 schema common order_single This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"reference/protocol.order_single/","text":"module protocol.order_single Generic FIX Order single module. Global Variables nan class FIXNewOrderSingle Generic FIXNewOrderSingle wrapper. Attributes: clord_id : current order ClOrdID orig_clord_id : order OrigClOrdID (when canceling / replacing) order_id : executed order id ticker : user order ticker side : order side price : order price qty : order quantity leaves_qty : order remaining qty cum_qty : order filled qty avg_px : average fill price ord_type : order type account : order account status : current order status target_price : order target execution price method __init__ __init__( clord_id: str, cl_ticker: str, side: FOrdSide | str, price: float, qty: float, ord_type: FOrdType | str = <FOrdType.LIMIT: '2'>, account: str | dict = '000000', target_price: float | None = None ) Initialize order. Args: clord_id : root ClOrdID cl_ticker : client ticker (can by any accepted by user's OMS) side : order side price : order initial price (current price, changes if replaced) qty : order quantity ord_type : order type account : order account (optional) target_price : order initial target execution price (useful for slippage) property clord_id_root Current order ClOrdID root. method can_cancel can_cancel() \u2192 bool Check if order can be canceled from its current state. method can_replace can_replace() \u2192 bool Check if order can be replaced from its current state. method cancel_req cancel_req() \u2192 FIXMessage Creates order cancel request. Raises: FIXError : if order can't be canceled method change_status change_status( status: FOrdStatus, fix_msg_type: FMsg, msg_exec_type: FExecType, msg_status: FOrdStatus, raise_on_err: bool = True ) \u2192 FOrdStatus | None FIX Order State transition algo. :param status: current order status :param fix_msg_type: incoming/or requesting order type, these are supported: '8' - execution report, '9' - Order Cancel reject, 'F' - Order cancel request (if possible to cancel current order) 'G' - Order replace request (if possible to replace current order) :param msg_exec_type: (only for execution report), for other should be 0 :param msg_status: new fix msg order status, or required status :return: FOrdStatus if state transition is possible, None - if transition is valid, but need to wait for a good state raises FIXError - when transition is invalid method clord_next clord_next() \u2192 str New ClOrdID for current order management. method clord_root clord_root(clord_id: str) \u2192 str Order ClOrdID root, as given at initialization. Args: clord_id : current order one of the clord_next() Returns: string method current_datetime current_datetime() Date for TransactTime field. method is_finished is_finished() \u2192 bool Check if order is in terminal state (no subsequent changes expected). method new_req new_req() \u2192 FIXMessage Creates NewOrderSingle message. method process_cancel_rej_report process_cancel_rej_report(m: FIXMessage) \u2192 bool Processes incoming cancel reject report message. method process_execution_report process_execution_report(m: FIXMessage) \u2192 bool Processes incoming execution report for an order. Raises: FIXError : if ClOrdID mismatch method replace_req replace_req(price: float = nan, qty: float = nan) \u2192 FIXMessage Creates order replace request. Args: price : alternative price qty : alternative qty Returns: message Raises: FIXError : if order can't be replaced or price/qty unchanged method set_account set_account(ord_msg: FIXMessage) Set account definition (override this in child). Args: ord_msg : new or replaced order method set_instrument set_instrument(ord_msg: FIXMessage) Set order instrument definition (override this in child). Args: ord_msg : new or replaced order method set_price_qty set_price_qty(ord_msg: FIXMessage, price: float, qty: float) Set order price and qty definition (override this in child). This method handles custom price/qty rounding/decimal formatting, or maybe conditional presence of two fields based on order type Args: ord_msg : new or replaced order price : new order price (unformatted / unrounded) qty : new order qty (unformatted / unrounded) This file was automatically generated via lazydocs .","title":"Protocol.order single"},{"location":"reference/protocol.order_single/#module-protocolorder_single","text":"Generic FIX Order single module.","title":"module protocol.order_single"},{"location":"reference/protocol.order_single/#global-variables","text":"nan","title":"Global Variables"},{"location":"reference/protocol.order_single/#class-fixnewordersingle","text":"Generic FIXNewOrderSingle wrapper. Attributes: clord_id : current order ClOrdID orig_clord_id : order OrigClOrdID (when canceling / replacing) order_id : executed order id ticker : user order ticker side : order side price : order price qty : order quantity leaves_qty : order remaining qty cum_qty : order filled qty avg_px : average fill price ord_type : order type account : order account status : current order status target_price : order target execution price","title":"class FIXNewOrderSingle"},{"location":"reference/protocol.order_single/#method-__init__","text":"__init__( clord_id: str, cl_ticker: str, side: FOrdSide | str, price: float, qty: float, ord_type: FOrdType | str = <FOrdType.LIMIT: '2'>, account: str | dict = '000000', target_price: float | None = None ) Initialize order. Args: clord_id : root ClOrdID cl_ticker : client ticker (can by any accepted by user's OMS) side : order side price : order initial price (current price, changes if replaced) qty : order quantity ord_type : order type account : order account (optional) target_price : order initial target execution price (useful for slippage)","title":"method __init__"},{"location":"reference/protocol.order_single/#property-clord_id_root","text":"Current order ClOrdID root.","title":"property clord_id_root"},{"location":"reference/protocol.order_single/#method-can_cancel","text":"can_cancel() \u2192 bool Check if order can be canceled from its current state.","title":"method can_cancel"},{"location":"reference/protocol.order_single/#method-can_replace","text":"can_replace() \u2192 bool Check if order can be replaced from its current state.","title":"method can_replace"},{"location":"reference/protocol.order_single/#method-cancel_req","text":"cancel_req() \u2192 FIXMessage Creates order cancel request. Raises: FIXError : if order can't be canceled","title":"method cancel_req"},{"location":"reference/protocol.order_single/#method-change_status","text":"change_status( status: FOrdStatus, fix_msg_type: FMsg, msg_exec_type: FExecType, msg_status: FOrdStatus, raise_on_err: bool = True ) \u2192 FOrdStatus | None FIX Order State transition algo. :param status: current order status :param fix_msg_type: incoming/or requesting order type, these are supported: '8' - execution report, '9' - Order Cancel reject, 'F' - Order cancel request (if possible to cancel current order) 'G' - Order replace request (if possible to replace current order) :param msg_exec_type: (only for execution report), for other should be 0 :param msg_status: new fix msg order status, or required status :return: FOrdStatus if state transition is possible, None - if transition is valid, but need to wait for a good state raises FIXError - when transition is invalid","title":"method change_status"},{"location":"reference/protocol.order_single/#method-clord_next","text":"clord_next() \u2192 str New ClOrdID for current order management.","title":"method clord_next"},{"location":"reference/protocol.order_single/#method-clord_root","text":"clord_root(clord_id: str) \u2192 str Order ClOrdID root, as given at initialization. Args: clord_id : current order one of the clord_next() Returns: string","title":"method clord_root"},{"location":"reference/protocol.order_single/#method-current_datetime","text":"current_datetime() Date for TransactTime field.","title":"method current_datetime"},{"location":"reference/protocol.order_single/#method-is_finished","text":"is_finished() \u2192 bool Check if order is in terminal state (no subsequent changes expected).","title":"method is_finished"},{"location":"reference/protocol.order_single/#method-new_req","text":"new_req() \u2192 FIXMessage Creates NewOrderSingle message.","title":"method new_req"},{"location":"reference/protocol.order_single/#method-process_cancel_rej_report","text":"process_cancel_rej_report(m: FIXMessage) \u2192 bool Processes incoming cancel reject report message.","title":"method process_cancel_rej_report"},{"location":"reference/protocol.order_single/#method-process_execution_report","text":"process_execution_report(m: FIXMessage) \u2192 bool Processes incoming execution report for an order. Raises: FIXError : if ClOrdID mismatch","title":"method process_execution_report"},{"location":"reference/protocol.order_single/#method-replace_req","text":"replace_req(price: float = nan, qty: float = nan) \u2192 FIXMessage Creates order replace request. Args: price : alternative price qty : alternative qty Returns: message Raises: FIXError : if order can't be replaced or price/qty unchanged","title":"method replace_req"},{"location":"reference/protocol.order_single/#method-set_account","text":"set_account(ord_msg: FIXMessage) Set account definition (override this in child). Args: ord_msg : new or replaced order","title":"method set_account"},{"location":"reference/protocol.order_single/#method-set_instrument","text":"set_instrument(ord_msg: FIXMessage) Set order instrument definition (override this in child). Args: ord_msg : new or replaced order","title":"method set_instrument"},{"location":"reference/protocol.order_single/#method-set_price_qty","text":"set_price_qty(ord_msg: FIXMessage, price: float, qty: float) Set order price and qty definition (override this in child). This method handles custom price/qty rounding/decimal formatting, or maybe conditional presence of two fields based on order type Args: ord_msg : new or replaced order price : new order price (unformatted / unrounded) qty : new order qty (unformatted / unrounded) This file was automatically generated via lazydocs .","title":"method set_price_qty"},{"location":"reference/protocol.protocol_base/","text":"module protocol.protocol_base Base FIX protocol. class FIXProtocolBase Generic FIX protocol. This file was automatically generated via lazydocs .","title":"Protocol.protocol base"},{"location":"reference/protocol.protocol_base/#module-protocolprotocol_base","text":"Base FIX protocol.","title":"module protocol.protocol_base"},{"location":"reference/protocol.protocol_base/#class-fixprotocolbase","text":"Generic FIX protocol. This file was automatically generated via lazydocs .","title":"class FIXProtocolBase"},{"location":"reference/protocol.protocol_fix44/","text":"module protocol.protocol_fix44 FIX Protocol 4.4 module. class FIXProtocol44 FIXProtocol 4.4 protocol definition class. This file was automatically generated via lazydocs .","title":"Protocol.protocol fix44"},{"location":"reference/protocol.protocol_fix44/#module-protocolprotocol_fix44","text":"FIX Protocol 4.4 module.","title":"module protocol.protocol_fix44"},{"location":"reference/protocol.protocol_fix44/#class-fixprotocol44","text":"FIXProtocol 4.4 protocol definition class. This file was automatically generated via lazydocs .","title":"class FIXProtocol44"},{"location":"reference/protocol.schema/","text":"module protocol.schema FIX Schema validation module. class SchemaField FIX Field schema. method __init__ __init__( tag: 'str', name: 'str', ftype: 'str', values: 'dict[str, str]' = <factory> ) \u2192 None method validate_value validate_value(value: 'str') \u2192 bool Validate tag value based on schema settings. Args: value : tag value Returns: True - if passed Raises: FIXMessageError : raised if validation failed class SchemaSet Generic schema set (base for component/group). Attributes: name : schema name field : schema field members : members required : required flag method __init__ __init__(name: 'str', field: 'SchemaField | None' = None) Initialize. Args: name : name of abstract set field : field of abstract set Raises: ValueError : if not NUMINGROUP type or similar tag name property tag Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field method add add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value method keys keys() \u2192 list[str] List of field names. method merge merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet class SchemaGroup SchemaGroup container. Attributes: field_required: method __init__ __init__(field: 'SchemaField', required: 'bool') Initialize. Args: field : SchemaField of group required : required flag property tag Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field method add add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value method keys keys() \u2192 list[str] List of field names. method merge merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet method validate_group validate_group(groups: 'list[FIXContainer]') Validate values of all tags in group. Args: groups : list of repeating group items Raises: FIXMessageError : validation failed class SchemaComponent SchemaComponent container. method __init__ __init__(name: 'str') Initialize. Args: name : component name property tag Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field method add add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value method keys keys() \u2192 list[str] List of field names. method merge merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet class SchemaHeader SchemaHeader container. method __init__ __init__() Initialize header. property tag Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field method add add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value method keys keys() \u2192 list[str] List of field names. method merge merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet class SchemaMessage SchemaMessage container. Attributes: msg_type : msg_type value msg_cat : message category method __init__ __init__(name: 'str', msg_type: 'str', msg_cat: 'str') Initialize. Args: name : message name msg_type : message type msg_cat : message category property tag Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field method add add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value method keys keys() \u2192 list[str] List of field names. method merge merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet class FIXSchema FIX schema validator. method __init__ __init__(xml_or_path: 'ElementTree | str') Initialize. Args: xml_or_path : path to xml or xml.etree.ElementTree Raises: ValueError: method validate validate(msg: 'FIXMessage') \u2192 bool Validates generic FIXMessage based on schema. Args: msg : generic FIXMessage Returns: True - if ok Raises: FIXMessageError : raises on invalid message This file was automatically generated via lazydocs .","title":"Protocol.schema"},{"location":"reference/protocol.schema/#module-protocolschema","text":"FIX Schema validation module.","title":"module protocol.schema"},{"location":"reference/protocol.schema/#class-schemafield","text":"FIX Field schema.","title":"class SchemaField"},{"location":"reference/protocol.schema/#method-__init__","text":"__init__( tag: 'str', name: 'str', ftype: 'str', values: 'dict[str, str]' = <factory> ) \u2192 None","title":"method __init__"},{"location":"reference/protocol.schema/#method-validate_value","text":"validate_value(value: 'str') \u2192 bool Validate tag value based on schema settings. Args: value : tag value Returns: True - if passed Raises: FIXMessageError : raised if validation failed","title":"method validate_value"},{"location":"reference/protocol.schema/#class-schemaset","text":"Generic schema set (base for component/group). Attributes: name : schema name field : schema field members : members required : required flag","title":"class SchemaSet"},{"location":"reference/protocol.schema/#method-__init___1","text":"__init__(name: 'str', field: 'SchemaField | None' = None) Initialize. Args: name : name of abstract set field : field of abstract set Raises: ValueError : if not NUMINGROUP type or similar tag name","title":"method __init__"},{"location":"reference/protocol.schema/#property-tag","text":"Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field","title":"property tag"},{"location":"reference/protocol.schema/#method-add","text":"add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value","title":"method add"},{"location":"reference/protocol.schema/#method-keys","text":"keys() \u2192 list[str] List of field names.","title":"method keys"},{"location":"reference/protocol.schema/#method-merge","text":"merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet","title":"method merge"},{"location":"reference/protocol.schema/#class-schemagroup","text":"SchemaGroup container. Attributes: field_required:","title":"class SchemaGroup"},{"location":"reference/protocol.schema/#method-__init___2","text":"__init__(field: 'SchemaField', required: 'bool') Initialize. Args: field : SchemaField of group required : required flag","title":"method __init__"},{"location":"reference/protocol.schema/#property-tag_1","text":"Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field","title":"property tag"},{"location":"reference/protocol.schema/#method-add_1","text":"add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value","title":"method add"},{"location":"reference/protocol.schema/#method-keys_1","text":"keys() \u2192 list[str] List of field names.","title":"method keys"},{"location":"reference/protocol.schema/#method-merge_1","text":"merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet","title":"method merge"},{"location":"reference/protocol.schema/#method-validate_group","text":"validate_group(groups: 'list[FIXContainer]') Validate values of all tags in group. Args: groups : list of repeating group items Raises: FIXMessageError : validation failed","title":"method validate_group"},{"location":"reference/protocol.schema/#class-schemacomponent","text":"SchemaComponent container.","title":"class SchemaComponent"},{"location":"reference/protocol.schema/#method-__init___3","text":"__init__(name: 'str') Initialize. Args: name : component name","title":"method __init__"},{"location":"reference/protocol.schema/#property-tag_2","text":"Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field","title":"property tag"},{"location":"reference/protocol.schema/#method-add_2","text":"add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value","title":"method add"},{"location":"reference/protocol.schema/#method-keys_2","text":"keys() \u2192 list[str] List of field names.","title":"method keys"},{"location":"reference/protocol.schema/#method-merge_2","text":"merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet","title":"method merge"},{"location":"reference/protocol.schema/#class-schemaheader","text":"SchemaHeader container.","title":"class SchemaHeader"},{"location":"reference/protocol.schema/#method-__init___4","text":"__init__() Initialize header.","title":"method __init__"},{"location":"reference/protocol.schema/#property-tag_3","text":"Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field","title":"property tag"},{"location":"reference/protocol.schema/#method-add_3","text":"add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value","title":"method add"},{"location":"reference/protocol.schema/#method-keys_3","text":"keys() \u2192 list[str] List of field names.","title":"method keys"},{"location":"reference/protocol.schema/#method-merge_3","text":"merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet","title":"method merge"},{"location":"reference/protocol.schema/#class-schemamessage","text":"SchemaMessage container. Attributes: msg_type : msg_type value msg_cat : message category","title":"class SchemaMessage"},{"location":"reference/protocol.schema/#method-__init___5","text":"__init__(name: 'str', msg_type: 'str', msg_cat: 'str') Initialize. Args: name : message name msg_type : message type msg_cat : message category","title":"method __init__"},{"location":"reference/protocol.schema/#property-tag_4","text":"Tag number of SchemaField. Returns: tag Raises: ValueError : raised then tag is not single field","title":"property tag"},{"location":"reference/protocol.schema/#method-add_4","text":"add(field_or_set: 'SchemaField | SchemaSet', required: 'bool') Add SchemaSet member. Args: field_or_set : field or SchemaSet required : required tag flag Raises: ValueError : unsupported field_or_set value","title":"method add"},{"location":"reference/protocol.schema/#method-keys_4","text":"keys() \u2192 list[str] List of field names.","title":"method keys"},{"location":"reference/protocol.schema/#method-merge_4","text":"merge(comp: 'SchemaSet') Merge SchemaSet with another. Args: comp : SchemaSet","title":"method merge"},{"location":"reference/protocol.schema/#class-fixschema","text":"FIX schema validator.","title":"class FIXSchema"},{"location":"reference/protocol.schema/#method-__init___6","text":"__init__(xml_or_path: 'ElementTree | str') Initialize. Args: xml_or_path : path to xml or xml.etree.ElementTree Raises: ValueError:","title":"method __init__"},{"location":"reference/protocol.schema/#method-validate","text":"validate(msg: 'FIXMessage') \u2192 bool Validates generic FIXMessage based on schema. Args: msg : generic FIXMessage Returns: True - if ok Raises: FIXMessageError : raises on invalid message This file was automatically generated via lazydocs .","title":"method validate"},{"location":"reference/session/","text":"module session FIXSession module. class FIXSession Generic FIX Session container. Attributes: key : session DB id sender_comp_id : session sender target_comp_id : session target next_num_out : next expected seq num out next_num_in : next expected seq num in method __init__ __init__(key, target_comp_id: str, sender_comp_id: str) Initialize session. Args: key : session DB id target_comp_id : session target sender_comp_id : session sender method allocate_next_num_out allocate_next_num_out() Increments next_num_out counter. method set_next_num_in set_next_num_in(msg: FIXMessage) \u2192 int Sets next_num_in based on incoming FIXMessage. Args: msg : incoming message Returns: - if OK - current message seq_no - if ERROR - 0 or -1 method validate_comp_ids validate_comp_ids(target_comp_id: str, sender_comp_id: str) \u2192 bool Ensure target_comp_id/sender_comp_id match. Args: target_comp_id : incoming target_comp_id sender_comp_id : incoming sender_comp_id Returns: bool This file was automatically generated via lazydocs .","title":"Session"},{"location":"reference/session/#module-session","text":"FIXSession module.","title":"module session"},{"location":"reference/session/#class-fixsession","text":"Generic FIX Session container. Attributes: key : session DB id sender_comp_id : session sender target_comp_id : session target next_num_out : next expected seq num out next_num_in : next expected seq num in","title":"class FIXSession"},{"location":"reference/session/#method-__init__","text":"__init__(key, target_comp_id: str, sender_comp_id: str) Initialize session. Args: key : session DB id target_comp_id : session target sender_comp_id : session sender","title":"method __init__"},{"location":"reference/session/#method-allocate_next_num_out","text":"allocate_next_num_out() Increments next_num_out counter.","title":"method allocate_next_num_out"},{"location":"reference/session/#method-set_next_num_in","text":"set_next_num_in(msg: FIXMessage) \u2192 int Sets next_num_in based on incoming FIXMessage. Args: msg : incoming message Returns: - if OK - current message seq_no - if ERROR - 0 or -1","title":"method set_next_num_in"},{"location":"reference/session/#method-validate_comp_ids","text":"validate_comp_ids(target_comp_id: str, sender_comp_id: str) \u2192 bool Ensure target_comp_id/sender_comp_id match. Args: target_comp_id : incoming target_comp_id sender_comp_id : incoming sender_comp_id Returns: bool This file was automatically generated via lazydocs .","title":"method validate_comp_ids"}]}